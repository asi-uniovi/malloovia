"Tests for utility functions in malloovia"
import ruamel.yaml
from jsonschema import validate

from malloovia import util
from malloovia import phases
from malloovia import Problem
from malloovia.solution_model import Status, SolvingStats, SolutionI, SolutionII, MallooviaStats
from .datapaths import PresetDataPaths

yaml = ruamel.yaml.YAML(typ='safe')
yaml.safe_load = yaml.load

# pylint: disable=invalid-name

class TestUtilModule(PresetDataPaths):
    """Test utility functions in malloovia"""

    def test_yaml_back_and_forth_is_the_same(self):
        """Test the writer for the problem yaml format, by reading it back"""
        # Read one example problem with YAML and get all the info as nested python dicts
        filename = self.get_valid("problem_example.yaml")
        with open(filename) as f:
            orig_raw_data = yaml.safe_load(f)

        # Convert those dicts to Malloovia classes
        problems = util.problems_from_dict(orig_raw_data, yaml_filename=filename)
        # Get the Yaml representation of Malloovia problems
        generated_yaml = util.problems_to_yaml(problems)
        # Convert it back to python dicts and those to Malloovia classes
        back_to_problems = util.problems_from_dict(yaml.safe_load(generated_yaml),
                                                   yaml_filename=filename)
        # Compare malloovia classes to ensure that they store the same information in the
        # problem originally read from disk, and in the one generated by util.problems_to_yaml()
        assert problems == back_to_problems

    def test_read_problem_with_external_workload(self):
        """Reads a yaml file which specifies a problem and uses 'filename' property of the
        workload to reference an external file, instead of having the list of numbers in the yaml"""
        filename = self.get_valid("problem_example_external_workload.yaml")
        prob = util.read_problems_from_yaml(filename)
        assert prob['phaseI'].workloads[0].filename == "external_workload.csv"
        assert isinstance(prob['phaseI'].workloads[0].values, tuple)
        assert isinstance(prob['phaseI'].workloads[0].values[0], float)
        assert prob['phaseI'].workloads[0].values == prob['phaseI'].workloads[1].values
        assert prob['phaseI'].workloads[0].values == (20.0, 12.0, 5.0, 6.0, 15.0, 4.0, 3.0)

    def test_convert_to_yaml_problem_with_external_workload(self):
        """Reads a yaml file which uses the `filename` property of the workload to reference an
        external file, converts the problem back to yaml and checks that the result also uses the
        `filename` property and does not contain a `values` property."""

        filename = self.get_valid("problem_example_external_workload.yaml")
        prob = util.read_problems_from_yaml(filename)
        generated_yaml = util.problems_to_yaml(prob)
        raw_data = yaml.safe_load(generated_yaml)
        assert "filename" in raw_data['Workloads'][0]
        assert  raw_data['Workloads'][0]['filename'] == 'external_workload.csv'
        assert "values" not in raw_data['Workloads'][0]

    def test_solution_i_to_yaml(self):
        """Reads problem1, solves first phase it and dumps the solution, which is validated
        against malloovia schema"""
        problems = util.read_problems_from_yaml(self.get_problem("problem1.yaml"))
        assert "example" in problems
        problem_phase_i = problems['example']

        sol_i = phases.PhaseI(problem_phase_i).solve()
        assert sol_i.solving_stats.algorithm.status == Status.optimal
        assert sol_i.solving_stats.optimal_cost == 178

        sol_i_yaml = util.solutions_to_yaml([sol_i])
        assert "true" in sol_i_yaml
        assert "True" not in sol_i_yaml
        assert "False" not in sol_i_yaml
        assert "None" not in sol_i_yaml
        sol_i_dict = yaml.safe_load(sol_i_yaml)
        with open(self.get_schema("malloovia.schema.yaml")) as file:
            sol_schema = yaml.safe_load(file)
        validate(sol_i_dict, sol_schema)

    def test_aborted_solution_i_to_yaml(self):
        """Reads problem1, creates an aborted solution and dumps the solution, which is validated
        against malloovia schema"""
        problems = util.read_problems_from_yaml(self.get_problem("problem1.yaml"))
        assert "example" in problems
        problem_phase_i = problems['example']

        algorithm_stats = MallooviaStats(
            gcd=False,
            status=Status.aborted)

        solving_stats = SolvingStats(
            algorithm=algorithm_stats,
            creation_time=0.3,
            solving_time=200,
            optimal_cost=None)

        sol_i = SolutionI(
            id='sol',
            problem=problem_phase_i,
            solving_stats=solving_stats,
            allocation=None,
            reserved_allocation=None)

        sol_i_yaml = util.solutions_to_yaml([sol_i])
        assert "true" in sol_i_yaml
        assert "True" not in sol_i_yaml
        assert "False" not in sol_i_yaml
        assert "null" in sol_i_yaml
        assert "None" not in sol_i_yaml
        sol_i_dict = yaml.safe_load(sol_i_yaml)
        with open(self.get_schema("malloovia.schema.yaml")) as file:
            sol_schema = yaml.safe_load(file)
        validate(sol_i_dict, sol_schema)

    def test_solution_ii_to_yaml(self):
        """Reads problem1, solves second phase and dumps the solution, which is validated
        against malloovia schema"""
        problems = util.read_problems_from_yaml(self.get_problem("problem1.yaml"))
        assert "example" in problems
        problem_phase_i = problems['example']

        sol_i = phases.PhaseI(problem_phase_i).solve()
        assert sol_i.solving_stats.algorithm.status == Status.optimal
        assert sol_i.solving_stats.optimal_cost == 178

        sol_ii = phases.PhaseII(problem_phase_i, sol_i).solve_period()
        assert sol_ii.global_solving_stats.status == Status.optimal
        assert sol_ii.global_solving_stats.optimal_cost == 178

        # It is necessary to dump both solutions, because phase ii contains
        # a reference to the solution of phase i
        sol_ii_yaml = util.solutions_to_yaml([sol_i, sol_ii])
        sol_ii_dict = yaml.safe_load(sol_ii_yaml)
        with open(self.get_schema("malloovia.schema.yaml")) as file:
            sol_schema = yaml.safe_load(file)
        validate(sol_ii_dict, sol_schema)


    def test_read_dataset_from_github(self):
        """Tests that files with several problems can be read from github URLs"""

        problems = util.read_problems_from_github(dataset="problem1")
        assert len(problems) == 1
        problem = list(problems.values())[0]
        assert len(problem.instance_classes) == 2
        assert len(problem.workloads) == 2
        assert problem.workloads[0].values == (30, 32, 30, 30)
        assert problem.workloads[1].values == (1003, 1200, 1194, 1003)

    def test_read_single_problem_from_github(self):
        """Test a single problem can be read from a github URL"""
        problem = util.read_problems_from_github(dataset="problem1", _id="example")
        assert len(problem.instance_classes) == 2
        assert len(problem.workloads) == 2
        assert problem.workloads[0].values == (30, 32, 30, 30)
        assert problem.workloads[1].values == (1003, 1200, 1194, 1003)

    def test_read_solution_from_file(self):
        """Tests that YAML files with both solutions and problem definitions can be
        read"""
        filename = self.get_valid('problems_plus_solutions_with_allocation.yaml')
        solutions = util.read_solutions_from_yaml(filename)

        assert len(solutions) == 2

        sol_phase_i = solutions['solution_phase_I']
        sol_phase_ii = solutions['solution_phase_II']

        assert isinstance(sol_phase_ii, SolutionII)
        assert sol_phase_ii.solving_stats[1]['optimal_cost'] == 0.23
        assert len(sol_phase_ii.allocation['apps']) == 2
        assert sol_phase_ii.allocation['apps'][0].name == 'Web server'
        assert sol_phase_i.allocation['apps'][1].name == 'Database'
        assert sol_phase_ii.allocation['instance_classes'][1].name == 'm4.medium'
        assert sol_phase_i.reserved_allocation['instance_classes'][0].name == 'm3.large'
        assert sol_phase_i.reserved_allocation['vms_number'][0] == 20
        assert isinstance(sol_phase_ii.problem, Problem)
        assert sol_phase_ii.previous_phase is sol_phase_i
